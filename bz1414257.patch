diff -Naurp pcp-3.10.9-orig/src/pcp/iostat/pcp-iostat.1 pcp-3.10.9/src/pcp/iostat/pcp-iostat.1
--- pcp-3.10.9-orig/src/pcp/iostat/pcp-iostat.1	2017-01-23 16:08:08.820751508 +1100
+++ pcp-3.10.9/src/pcp/iostat/pcp-iostat.1	2017-01-23 15:36:26.610335231 +1100
@@ -1,7 +1,7 @@
 '\"! tbl | mmdoc
 '\"macro stdmacro
 .\"
-.\" Copyright (c) 2014-2015 Red Hat.  All Rights Reserved.
+.\" Copyright (c) 2014-2016 Red Hat.  All Rights Reserved.
 .\" 
 .\" This program is free software; you can redistribute it and/or modify it
 .\" under the terms of the GNU General Public License as published by the
@@ -23,17 +23,20 @@
 \f3pcp\ iostat\f1
 [\f3\-A\f1 \f2align\f1 \f3--align=\f2TIME\f1]
 [\f3\-a\f1 \f2archive\f1 \f3--archive=\f2FILE\f1]
+[\f3\-G\f1 \f2method\f1 \f3--aggregate=\f2method\f1]
 [\f3\-h\f1 \f2host\f1 \f3--host=\f2HOST\f1]
 [\f3\-O\f1 \f2offset\f1 \f3--origin=\f2TIME\f1]
 [\f3\-S\f1 \f2starttime\f1 \f3--start=\f2TIME\f1]
 [\f3\-s\f1 \f2samples\f1 \f3--samples=\f2N\f1]
 [\f3\-T\f1 \f2endtime\f1 \f3--finish=\f2TIME\f1]
 [\f3\-t\f1 \f2interval\f1 \f3--interval=\f2DELTA\f1]
+[\f3\-P\f1 \f2precision\f1 \f3--precision=\f2N\f1]
+[\f3\-R\f1 \f2pattern\f1 \f3--regex=\f2pattern\f1]
 [\f3\-u\f1 \f3--no-interpolate\f1]
 [\f3\-Z\f1 \f2timezone\f1 \f3--timezone=\f2TZ\f1]
 [\f3\-z\f1 \f3--hostzone\f1]
 [\f3\-?\f1 \f3--help\f1]
-[\f3\-x\f1 [dm][,t][,h]\f1]
+[\f3\-x\f1 [dm][,t][,h][,noidle]\f1]
 .SH DESCRIPTION
 .de EX
 .in +0.5i
@@ -76,11 +79,67 @@ are as follows:
 .TP 5
 .B \-a
 Performance metric values are retrieved from the Performance Co-Pilot (PCP)
-archive log file identified by the base name
-.IR archive .
-See also
+archive log files identified by the argument
+.IR archive ,
+which is a comma-separated list of
+names, each of which may be the base name of an archive or the name of a
+directory containing one or more archives. See also
 .BR \-u .
 .TP
+.B \-G
+Specifies that statistics for device names matching the regular expression specified with the
+.B \-R
+.I regex
+option should be aggregated according to
+.IR method .
+Note this is aggregation based on matching device names (not temporal aggregation).
+When
+.B \-G
+is used,
+the device name column is reported as
+.IR method (\fIregex\fR),
+e.g.
+if
+.B \-G sum
+.B \-R 'sd(a|b)$'
+is specified, the device column will be
+.BR sum (\fBsd(a|b)$)\fR
+and
+summed statistics for
+.B sda
+and
+.B sdb
+will be reported in the remaining columns.
+If
+.B \-G
+is specified but
+.B \-R
+is not specified, then the default
+.I regex
+is
+.BR .* ,
+i.e. matching all device names.
+If
+.I method
+is
+.B sum
+then the statistics are summed.
+This includes the
+.B %util
+column, which may therefore exceed 100% if more than one device name matches.
+If
+.I method
+is
+.B avg
+then the statistics are summed and then averaged by dividing by the number of matching device names.
+If
+.I method
+is
+.B min
+or
+.BR max ,
+the minimum or maximum statistics for matching devices are reported, respectfully.
+.TP
 .B \-h
 Current performance metric values are retrieved from the nominated
 .I host
@@ -97,7 +156,7 @@ is 0 or
 is not specified, 
 .B pcp-iostat
 will sample and report continuously (in real time mode) or until the end
-of the PCP archive (in archive mode).
+of the set of PCP archives (in archive mode).
 .TP
 .B \-t
 The default update \f2interval\f1 may be set to something other than the
@@ -108,7 +167,8 @@ argument follows the syntax described in
 .BR PCPIntro (1),
 and in the simplest form may be an unsigned integer (the implied
 units in this case are seconds).
-The \f3-t\fP option is particularly useful when replaying large archives (\f3-a\fP option) that span several hours or even days.
+The \f3-t\fP option is particularly useful when replaying large sets of
+archives (\f3-a\fP option) that span several hours or even days.
 In this case specifying a large
 .I interval
 (e.g. 1h for 1 hour)
@@ -117,30 +177,53 @@ the reporting interval (unless the
 .B \-u
 option is specified, see below).
 .TP
+.B \-R
+This restricts the report to device names matching
+.IR regex .
+The
+.I regex
+pattern is searched as a perl style regular expression, and will match any portion of a device name.
+e.g. '^sd[a-zA-Z]+' will match all device names starting with 'sd' followed by one or more alphabetic characters.
+e.g. '^sd(a|b)$' will only match 'sda' and 'sdb'.
+e.g. 'sda$' will match 'sda' but not 'sdab'.
+See also the
+.B -G
+option for aggregation options.
+.TP
+.B \-P
+This indicates the number of decimals to print. The default precision \f2N\f1
+may be set to something other than the default 2 decimals.
+Note that the
+.B avgrq-sz
+and
+.B avgqu-sz
+fields are always reported with \f2N\f1+1 decimals of precision.
+These fields typically have values less than 1.0.
+.TP
 .B \-u
-When replaying an archive, by default values are reported
+When replaying a set of archives, by default values are reported
 according to the selected sample interval (\c
 .B \-t
-option), not according to the actual record intervals in the archive.
+option), not according to the actual record intervals in the set of archives.
 To this effect PCP interpolates the values to be reported based on the
-records in the archive, and is particularly useful when the
+records in the set of archives, and is particularly useful when the
 .B \-t
-option is used to replay an archive with a longer sampling interval than
-the underlying interval the archive was originally recorded with.
+option is used to replay a set of archives with a longer sampling interval than
+the underlying interval the set of archives was originally recorded with.
 With the
 .B \-u
 option,
 uninterpolated reporting is enabled - every value is reported
-according to the native recording interval in the archive.
+according to the native recording interval in the set of archives.
 When the
 .B \-u
 option is specified, the
 .B \-t
 option makes no sense and is incompatible because the replay interval
-is always the same as the recording interval in the archive.
+is always the same as the recording interval in the set of archive.
 In addition,
 .B \-u
-only makes sense when replaying an archive, see
+only makes sense when replaying a set of archives, see
 .B \-a
 above,
 and so if
@@ -172,6 +255,10 @@ the source of the performance metrics, a
 or
 .B \-a
 options.
+When replaying a PCP archive that was captured in a foreign timezone, the
+.B \-z
+option would almost always be used (the default reporting timezone is the local timezone,
+which may not be the same as the timezone of the PCP archive).
 .TP
 .B \-x
 Specifies a comma separated list of one or more extended reporting options as follows:
@@ -180,7 +267,9 @@ Specifies a comma separated list of one
 .br
 \f3t\fP - prefix every line in the report with a timestamp in \f2ctime\fP(3) format,
 .br
-\f3H\fP - omit the heading, which is otherwise reported every 24 samples.
+\f3h\fP - omit the heading, which is otherwise reported every 24 samples,
+.br
+\f3noidle\fP - Do not display statistics for idle devices.
 .SH REPORT
 The columns in the
 .B pcp-iostat
@@ -191,6 +280,13 @@ When the \f3-x t\fP option is specified,
 .TP
 .B Device
 Specifies the scsi device name, or if \f3-x dm\fP is specified, the device-mapper logical device name.
+When
+.B \-G
+is specified, this is replaced by the aggregation method and regular expression - see the
+.B \-G
+and
+.B \-R
+options above.
 .TP
 .B rrqm/s
 The number of read requests expressed as a rate per-second that were merged
diff -Naurp pcp-3.10.9-orig/src/pcp/iostat/pcp-iostat.py pcp-3.10.9/src/pcp/iostat/pcp-iostat.py
--- pcp-3.10.9-orig/src/pcp/iostat/pcp-iostat.py	2017-01-23 16:08:08.821751495 +1100
+++ pcp-3.10.9/src/pcp/iostat/pcp-iostat.py	2017-01-23 15:28:44.841554701 +1100
@@ -1,6 +1,5 @@
 #!/usr/bin/pcp python
-#
-# Copyright (C) 2014-2015 Red Hat.
+# Copyright (C) 2014-2016 Red Hat.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
@@ -15,10 +14,15 @@
 # pylint: disable=C0103,R0914,R0902
 """ Display disk and device-mapper I/O statistics """
 
+import re
 import sys
+import signal
 from pcp import pmapi, pmcc
 from cpmapi import PM_TYPE_U64, PM_CONTEXT_ARCHIVE, PM_SPACE_KBYTE, PM_MODE_FORW
 
+# use default SIGPIPE handler to avoid broken pipe exceptions
+signal.signal(signal.SIGPIPE, signal.SIG_DFL)
+
 IOSTAT_SD_METRICS = [ 'disk.dev.read', 'disk.dev.read_bytes',
                  'disk.dev.write', 'disk.dev.write_bytes',
                  'disk.dev.read_merge', 'disk.dev.write_merge',
@@ -33,12 +37,28 @@ IOSTAT_DM_METRICS = [ 'disk.dm.read', 'd
                  'disk.dm.read_rawactive', 'disk.dm.write_rawactive',
                  'disk.dm.avactive']
 
+def aggregate(method, aggr_value, value):
+    if method == 'sum':
+        aggr_value += value
+    elif method == 'avg':
+        aggr_value += value
+    elif method == 'min':
+        if aggr_value > value:
+            aggr_value = value
+    elif method == 'max':
+        if aggr_value < value:
+            aggr_value = value
+    else:
+       raise pmapi.pmUsageErr
+    return aggr_value
+
 class IostatReport(pmcc.MetricGroupPrinter):
     Hcount = 0
     def timeStampDelta(self, group):
-        c = 1000000.0 * group.timestamp.tv_sec + group.timestamp.tv_usec
-        p = 1000000.0 * group.prevTimestamp.tv_sec + group.prevTimestamp.tv_usec
-        return (c - p) / 1000000.0
+        s = group.timestamp.tv_sec - group.prevTimestamp.tv_sec
+        u = group.timestamp.tv_usec - group.prevTimestamp.tv_usec
+        # u may be negative here, calculation is still correct.
+        return (s + u / 1000000.0)
 
     def instlist(self, group, name):
         return dict(map(lambda x: (x[1], x[2]), group[name].netValues)).keys()
@@ -50,6 +70,20 @@ class IostatReport(pmcc.MetricGroupPrint
         return dict(map(lambda x: (x[1], x[2]), group[name].netPrevValues))
 
     def report(self, manager):
+        regex = IostatOptions.Rflag
+        if regex == '':
+            regex = '.*'
+
+        aggr = IostatOptions.Gflag
+        if aggr and aggr not in ('sum', 'avg', 'min', 'max'):
+           print("Error, -G aggregation method must be one of 'sum', 'avg', 'min' or 'max'")
+           raise pmapi.pmUsageErr
+
+        precision = IostatOptions.Pflag
+        if precision < 0 or precision > 10 :
+           print("Precision value must be between 0 and 10")
+           raise pmapi.pmUsageErr
+
         if 'dm' in IostatOptions.xflag:
             subtree = 'disk.dm'
         else:
@@ -90,12 +124,38 @@ class IostatReport(pmcc.MetricGroupPrint
 
         c_avactive = self.curVals(group, subtree + '.avactive')
         p_avactive = self.prevVals(group, subtree + '.avactive')
-
-        if p_rrqm == {} or p_wrqm == {} or p_r == {} or p_w == {} or \
-           p_ractive == {} or p_wactive == {} or p_avactive == {} or \
-           p_rkb == {} or p_wkb == {}:
-            # no values for some metric (e.g. near start of archive)
-            return
+        
+        if precision == 1:
+           utilspace=precision+5
+           avgrqszspace=precision+7
+           awaitspace=precision+6
+           rrqmspace=precision+5
+           wrqmspace=precision+5
+           headfmtavgspace=precision+7
+           headfmtquspace=precision+7
+        elif precision == 0:
+           utilspace=precision+5
+           avgrqszspace=precision+8
+           awaitspace=precision+7
+           rrqmspace=precision+6
+           wrqmspace=precision+6
+           headfmtavgspace=avgrqszspace
+           headfmtquspace=precision+8
+        else:
+           utilspace=precision+5
+           avgrqszspace=precision+6
+           awaitspace=precision+5
+           rrqmspace=precision+5
+           wrqmspace=precision+5
+           headfmtavgspace=avgrqszspace
+           headfmtquspace=precision+6
+
+        if "t" in IostatOptions.xflag:
+            headfmt = "%-24s %-12s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s"
+            valfmt = "%-24s %-12s %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f"
+        else:
+            headfmt = "%-12s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s"
+            valfmt = "%-12s %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f %*.*f"
 
         if "h" not in IostatOptions.xflag:
             self.Hcount += 1
@@ -103,15 +163,31 @@ class IostatReport(pmcc.MetricGroupPrint
                 self.Hcount = 1
             if self.Hcount == 1:
                 if "t" in IostatOptions.xflag:
-                    heading = ('# Timestamp', 'Device', 'rrqm/s', 'wrqm/s', 'r/s', 'w/s', 'rkB/s', 'wkB/s',
-                               'avgrq-sz', 'avgqu-sz', 'await', 'r_await', 'w_await', '%util')
-                    print("%-24s %-12s %7s %7s %6s %6s %8s %8s %8s %8s %7s %7s %7s %5s" % heading)
+                    heading = ('# Timestamp', 'Device',rrqmspace, 'rrqm/s',wrqmspace, 'wrqm/s',precision+5, 'r/s',precision+4,\
+                    'w/s',precision+6, 'rkB/s',precision+6, 'wkB/s', avgrqszspace,'avgrq-sz',precision+6, 'avgqu-sz',precision+5, \
+                    'await',precision+5, 'r_await', precision+5,'w_await',utilspace, '%util')
                 else:
-                    heading = ('# Device', 'rrqm/s', 'wrqm/s', 'r/s', 'w/s', 'rkB/s', 'wkB/s',
-                               'avgrq-sz', 'avgqu-sz', 'await', 'r_await', 'w_await', '%util')
-                    print("%-12s %7s %7s %6s %6s %8s %8s %8s %8s %7s %7s %7s %5s" % heading)
+                    heading = ('# Device',rrqmspace, 'rrqm/s',wrqmspace, 'wrqm/s',precision+5, 'r/s',precision+4, 'w/s'\
+                    ,precision+6, 'rkB/s',precision+6, 'wkB/s', avgrqszspace,'avgrq-sz',precision+6, 'avgqu-sz',precision+5,\
+                    'await',awaitspace, 'r_await',awaitspace, 'w_await',utilspace, '%util')
+                print(headfmt % heading)
+
+        if p_rrqm == {} or p_wrqm == {} or p_r == {} or p_w == {} or \
+           p_ractive == {} or p_wactive == {} or p_avactive == {} or \
+           p_rkb == {} or p_wkb == {}:
+            # no values for some metric (e.g. near start of archive)
+            if "t" in IostatOptions.xflag:
+                print(headfmt % (timestamp, 'NODATA',rrqmspace, '?',wrqmspace, '?',precision+5, '?',precision+4, '?',precision+6,\
+               '?',precision+6, '?',headfmtavgspace, '?',headfmtquspace, '?', precision+5, '?',awaitspace, '?',awaitspace, '?',\
+                utilspace, '?'))
+            return
 
         try:
+            if IostatOptions.Gflag:
+                aggr_rrqm = aggr_wrqm = aggr_r = aggr_w = aggr_rkb = aggr_wkb = aggr_avgrqsz = 0.0
+                aggr_avgqsz = aggr_await = aggr_r_await = aggr_w_await = aggr_util = 0.0
+                aggr_count = 0
+
             for inst in sorted(instlist):
                 # basic stats
                 rrqm = (c_rrqm[inst] - p_rrqm[inst]) / dt
@@ -153,12 +229,94 @@ class IostatReport(pmcc.MetricGroupPrint
                     util = 100.0 * tot_active / dt
 
                 device = inst	# prepare name for printing
+                badcounters = rrqm < 0 or wrqm < 0 or r < 0 or w < 0 or await < 0 or avgrqsz < 0 or avgqsz < 0 or util < 0
+
                 if "t" in IostatOptions.xflag:
-                    print("%-24s %-12s %7.1f %7.1f %6.1f %6.1f %8.1f %8.1f %8.2f %8.2f %7.1f %7.1f %7.1f %5.1f" \
-                    % (timestamp, device, rrqm, wrqm, r, w, rkb, wkb, avgrqsz, avgqsz, await, r_await, w_await, util))
+                    if badcounters:
+                        print(headfmt % (timestamp, device,rrqmspace, '?',wrqmspace, '?',precision+5, '?',precision+4, '?',precision+6,\
+                        '?',precision+6, '?',headfmtavgspace, '?',headfmtquspace, '?', precision+5, '?',awaitspace, '?',\
+                        awaitspace, '?',utilspace, '?'))
+                    else:
+                        if IostatOptions.Rflag and re.search(regex,device) == None: 
+                            continue  
+
+                        if IostatOptions.Gflag:
+                            aggr_count += 1
+
+                        if "noidle" in IostatOptions.xflag:
+                            if rrqm == 0 and wrqm == 0 and r == 0 and w == 0 :
+                                continue
+
+                        if not IostatOptions.Gflag:
+                            print(valfmt % (timestamp, device,rrqmspace, precision, rrqm,wrqmspace,precision, wrqm,precision+5,precision,\
+                            r,precision+4,precision, w,precision+6,precision, rkb,precision+6,precision, wkb, avgrqszspace,precision+1 ,avgrqsz,\
+                            avgrqszspace,precision+1, avgqsz,precision+5,precision, await,awaitspace,precision, r_await,awaitspace,precision,\
+                            w_await,utilspace,precision, util))
                 else:
-                    print("%-12s %7.1f %7.1f %6.1f %6.1f %8.1f %8.1f %8.2f %8.2f %7.1f %7.1f %7.1f %5.1f" \
-                    % (device, rrqm, wrqm, r, w, rkb, wkb, avgrqsz, avgqsz, await, r_await, w_await, util))
+                    if badcounters:
+                        print(headfmt % (device,rrqmspace, '?',wrqmspace, '?',precision+5, '?',precision+4, '?',precision+6, '?',precision+6,\
+                        '?',headfmtavgspace, '?',headfmtquspace, '?', precision+5, '?',awaitspace, '?',awaitspace, '?',utilspace, '?'))
+                    else:
+                        if IostatOptions.Rflag and re.search(regex,device) == None: 
+                            continue  
+
+                        if IostatOptions.Gflag:
+                            aggr_count += 1
+
+                        if "noidle" in IostatOptions.xflag:
+                            if rrqm == 0 and wrqm == 0 and r == 0 and w == 0 :
+                                continue
+
+                        if not IostatOptions.Gflag:
+                            print(valfmt % (device,rrqmspace, precision, rrqm,wrqmspace,precision, wrqm,precision+5,precision, r,precision+4,\
+                            precision, w,precision+6,precision, rkb,precision+6,precision, wkb,\
+                            avgrqszspace,precision+1 ,avgrqsz,avgrqszspace,precision+1, avgqsz,precision+5,precision, await,awaitspace,precision,\
+                            r_await,awaitspace,precision, w_await,utilspace,precision, util))
+
+                if IostatOptions.Gflag and not badcounters:
+                    aggr_rrqm = aggregate(aggr, aggr_rrqm, rrqm)
+                    aggr_wrqm = aggregate(aggr, aggr_wrqm, wrqm)
+                    aggr_r = aggregate(aggr, aggr_r, r)
+                    aggr_w = aggregate(aggr, aggr_w, w)
+                    aggr_rkb = aggregate(aggr, aggr_rkb, rkb)
+                    aggr_wkb = aggregate(aggr, aggr_wkb, wkb)
+                    aggr_avgrqsz = aggregate(aggr, aggr_avgrqsz, avgrqsz)
+                    aggr_avgqsz = aggregate(aggr, aggr_avgqsz, avgqsz)
+                    aggr_await = aggregate(aggr, aggr_await, await)
+                    aggr_r_await = aggregate(aggr, aggr_r_await, r_await)
+                    aggr_w_await = aggregate(aggr, aggr_w_await, w_await)
+                    aggr_util = aggregate(aggr, aggr_util, util)
+            # end of loop
+
+            if IostatOptions.Gflag:
+                if IostatOptions.Gflag == 'avg' and aggr_count > 0:
+                    aggr_rrqm /= aggr_count
+                    aggr_wrqm /= aggr_count
+                    aggr_r /= aggr_count
+                    aggr_w /= aggr_count
+                    aggr_rkb /= aggr_count
+                    aggr_wkb /= aggr_count
+                    aggr_avgrqsz /= aggr_count
+                    aggr_avgqsz /= aggr_count
+                    aggr_await /= aggr_count
+                    aggr_r_await /= aggr_count
+                    aggr_w_await /= aggr_count
+                    aggr_util /= aggr_count
+
+
+                # report aggregate values - the 'device' here is reported as the regex used for the aggregation
+                device = '%s(%s)' % (aggr, regex)
+                if "t" in IostatOptions.xflag:
+                    print(valfmt % (timestamp, device,rrqmspace, precision, aggr_rrqm,wrqmspace,precision, aggr_wrqm,precision+5,precision,\
+                    aggr_r,precision+4,precision, aggr_w,precision+6,precision, aggr_rkb,precision+6,precision, aggr_wkb, avgrqszspace,precision+1 ,aggr_avgrqsz,\
+                    avgrqszspace,precision+1, aggr_avgqsz,precision+5,precision, aggr_await,awaitspace,precision, aggr_r_await,awaitspace,precision,\
+                    aggr_w_await,utilspace,precision, aggr_util))
+                else:
+                    print(valfmt % (device,rrqmspace, precision, aggr_rrqm,wrqmspace,precision, aggr_wrqm,precision+5,precision, aggr_r,precision+4,\
+                    precision, aggr_w,precision+6,precision, aggr_rkb,precision+6,precision, aggr_wkb,\
+                    avgrqszspace,precision+1 ,aggr_avgrqsz,avgrqszspace,precision+1, aggr_avgqsz,precision+5,precision, aggr_await,awaitspace,precision,\
+                    aggr_r_await,awaitspace,precision, aggr_w_await,utilspace,precision, aggr_util))
+
         except KeyError:
             # instance missing from previous sample
             pass
@@ -167,8 +325,10 @@ class IostatOptions(pmapi.pmOptions):
     # class attributes
     xflag = [] 
     uflag = None
-
-    def checkOptions(manager):
+    Pflag = 2
+    Rflag = ""
+    Gflag = ""
+    def checkOptions(self, manager):
         if IostatOptions.uflag:
             if manager._options.pmGetOptionInterval():
                 print("Error: -t incompatible with -u")
@@ -183,16 +343,25 @@ class IostatOptions(pmapi.pmOptions):
             IostatOptions.xflag += optarg.replace(',', ' ').split(' ')
         elif opt == "u":
             IostatOptions.uflag = True
+        elif opt == "P":
+            IostatOptions.Pflag = int(optarg)
+        elif opt == "R":
+            IostatOptions.Rflag = optarg
+        elif opt == "G":
+            IostatOptions.Gflag = optarg
 
     def __init__(self):
-        pmapi.pmOptions.__init__(self, "A:a:D:h:O:S:s:T:t:uVZ:z?x:")
+        pmapi.pmOptions.__init__(self, "A:a:D:G:h:O:P:R:S:s:T:t:uVZ:z?x:")
         self.pmSetOptionCallback(self.extraOptions)
         self.pmSetLongOptionHeader("General options")
         self.pmSetLongOptionAlign()
         self.pmSetLongOptionArchive()
         self.pmSetLongOptionDebug()
+        self.pmSetLongOption("aggregate", 1, "G", "method", "aggregate values for devices matching -R regex using 'method' (sum, avg, min or max)")
         self.pmSetLongOptionHost()
         self.pmSetLongOptionOrigin()
+        self.pmSetLongOption("precision", 1, "P", "N", "N digits after the decimal separator")
+        self.pmSetLongOption("regex", 1, "R", "pattern", "only report for devices names matching pattern, e.g. 'sd[a-zA-Z]+'. See also -G.")
         self.pmSetLongOptionStart()
         self.pmSetLongOptionSamples()
         self.pmSetLongOptionFinish()
@@ -203,15 +372,17 @@ class IostatOptions(pmapi.pmOptions):
         self.pmSetLongOptionHostZone()
         self.pmSetLongOptionHelp()
         self.pmSetLongOptionHeader("Extended options")
-        self.pmSetLongOption("", 1, 'x', "LIST", "comma separated extended options: [[dm],[t],[h]]")
+        self.pmSetLongOption("", 1, 'x', "LIST", "comma separated extended options: [[dm],[t],[h],[noidle]]")
         self.pmSetLongOptionText("\t\tdm\tshow device-mapper statistics (default is sd devices)")
         self.pmSetLongOptionText("\t\tt\tprecede every line with a timestamp in ctime format");
         self.pmSetLongOptionText("\t\th\tsuppress headings");
+        self.pmSetLongOptionText("\t\tnoidle\tdo not display idle devices");
 
 if __name__ == '__main__':
     try:
-        manager = pmcc.MetricGroupManager.builder(IostatOptions(), sys.argv)
-        if not IostatOptions.checkOptions(manager):
+        opts = IostatOptions()
+        manager = pmcc.MetricGroupManager.builder(opts, sys.argv)
+        if not opts.checkOptions(manager):
             raise pmapi.pmUsageErr
 
         if IostatOptions.uflag:
@@ -226,7 +397,7 @@ if __name__ == '__main__':
         sts = manager.run()
         sys.exit(sts)
     except pmapi.pmErr as error:
-        sys.write.stderr('%s: %s\n' % (error.progname(), error.message()))
+        sys.stderr.write('%s: %s\n' % (error.progname(), error.message()))
     except pmapi.pmUsageErr as usage:
         usage.message()
         sys.exit(1)
